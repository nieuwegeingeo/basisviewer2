/* ======================================================================
    Geodan.js
   ====================================================================== */

/* 
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

var Geodan = Geodan || {};

// maak beschikbaar als globale variabele onder IE
window.Geodan = Geodan;
/* ======================================================================
    Geodan/Format/GeocodeResponse.js
   ====================================================================== */

// $Id: GeocodeResponse.js 122 2011-06-29 14:57:44Z johnp $

Geodan.Format = Geodan.Format || {};

/**
 * Class: Geodan.Format.GeocodeRequest
 * Read/Write GeocodeRequest. 
 *
 * Inherits from:
 *  - <OpenLayers.Format.GML>
 */
Geodan.Format.GeocodeResponse = OpenLayers.Class(OpenLayers.Format.GML, {
  
/**
 * APIProperty: xlsns
 */
    xlsns: 'http://www.opengis.net/xls',

    initialize: function(options) {
        OpenLayers.Format.GML.prototype.initialize.apply(this, [options]);

        this.featureName = 'xls:GeocodedAddress';

        this.setNamespace('gml', 'http://www.opengis.net/gml');
    },

    read: function(data) {
        if(typeof data == "string") {
            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
        }

        var geocodedAddressNodes = this.getElementsByTagNameNS(data.documentElement,
            this.xlsns, 'GeocodedAddress');
        var geocodedAddresses = [];
        for (var i = 0; i < geocodedAddressNodes.length; i++) {
            var geocodedAddress = this.parseGeocodedAddress(geocodedAddressNodes[i]);
            if (geocodedAddress) {
                geocodedAddresses.push(geocodedAddress);
            }
        }
        return geocodedAddresses;
    },

    parseGeocodedAddress: function(node) {
        var children, geocodedAddress = {}, nodeList;

        nodeList = this.getElementsByTagNameNS(node, this.namespaces['gml'], 'Point');
        if (nodeList.length > 0) {
            var parser = this.parseGeometry['point'];
            geocodedAddress.geometry = parser.apply(this, [nodeList[0]]);
        }

        nodeList = this.getElementsByTagNameNS(node, this.xlsns, 'Address');
        if (nodeList.length > 0) {
            // street & building
            children = this.getElementsByTagNameNS(nodeList[0], this.xlsns, 'StreetAddress');
            if (children.length > 0) {
                var childNode = children[0].firstChild;
                while (childNode) {
                    if (childNode.nodeType == 1) {
                        if (childNode.tagName == 'xls:Street') {
                            geocodedAddress.street = this.getChildValue(childNode);
                        }
                        else if (childNode.tagName == 'xls:Building') {
                            geocodedAddress.number = childNode.getAttribute('number');
                            geocodedAddress.subdivision = childNode.getAttribute('subdivision');
                        }
                    }
                    childNode = childNode.nextSibling;
                }
            }

            // postalCode
            children = this.getElementsByTagNameNS(nodeList[0], this.xlsns, 'PostalCode');
            if (children.length > 0) {
                geocodedAddress.postalCode = this.getChildValue(children[0]);
            }

            // place(s)
            children = this.getElementsByTagNameNS(nodeList[0], this.xlsns, 'Place');
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                var type = child.getAttribute('type');
                var name = type.substr(0, 1).toLowerCase() + type.substr(1);
                geocodedAddress[name] = this.getChildValue(child);
                if (name === 'countrySecondarySubdivision') {
                    // todo: check geometrie to set geocodedAddress['extent']
                    var geom = OpenLayers.Geometry.fromWKT(geocodedAddress[name]);
                    if (geom) {
                        geocodedAddress['extent'] = geom.getBounds();
                    }
                }
            }
        }

        //console && console.info('geocoded address', geocodedAddress);
        return geocodedAddress;
    },

    CLASS_NAME: 'Geodan.Format.GeocodeResponse'
});
/* ======================================================================
    Geodan/Format/ReverseGeocodeRequest.Format.js
   ====================================================================== */

// $Id$

/**
 * Class: Geodan.Format.ReverseGeocodeRequest
 * Read/Write ReverseGeocodeRequest. 
 *
 * Inherits from:
 *  - <OpenLayers.Format.GML>
 */
Geodan.Format.ReverseGeocodeRequest = OpenLayers.Class(OpenLayers.Format.GML, {
  
  /**
   * APIProperty: xlsns
   */
  xlsns: 'http://www.opengis.net/xls',
  
  initialize: function(options, position) {
    OpenLayers.Format.GML.prototype.initialize.apply(this, [options]);
    
    this.setNamespace('xls', this.xlsns);
    
    this.position = OpenLayers.Util.extend({}, position);
  },
  
  write: function() {
    var xml = '<xls:ReverseGeocodeRequest xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xls="http://www.opengis.net/xls" xmlns:gml="http://www.opengis.net/gml"><xls:Position><gml:Point srsName="EPSG:28992"><gml:pos dimension="2">'
      + this.position.x + ' ' + this.position.y + '</gml:pos></gml:Point></xls:Position></xls:ReverseGeocodeRequest>';
    return xml;
    
    var request = this.createElementNS(this.xlsns, 'xls:ReverseGeocodeRequest');
    request.setAttribute('xmlns:gml', this.gmlns);
    request.setAttribute('xmlns:xsi', "http://www.w3.org/2001/XMLSchema-instance");
    
    request.appendChild(this.createPosition());
    
    return OpenLayers.Format.XML.prototype.write.apply(this, [request]);
  },
  
  createPosition: function() {
    var node = this.createElementNS(this.xlsns, 'xls:Position');
    
    var pointNode = this.createElementNSPlus('gml:Point', {
      uri: this.gmlns,
      attributes: { srsName: 'EPSG:28992' }
    });
    pointNode.appendChild(this.createElementNSPlus('gml:pos', {
      uri: this.gmlns,
      value: this.position.x + ' ' + this.position.y,
      attributes: { dimension: 2 }
    }));
    node.appendChild(pointNode);
    
    return node;
  },
  
  CLASS_NAME: 'Geodan.Format.ReverseGeocodeRequest'
});
/* ======================================================================
    Geodan/Format/ReverseGeocodeResponse.Format.js
   ====================================================================== */

// $Id$

/**
 * Class: Geodan.Format.ReverseGeocodeResponse
 * Read/Write ReverseGeocodeResponse. 
 *
 * Inherits from:
 *  - <OpenLayers.Format.GML>
 */
Geodan.Format.ReverseGeocodeResponse = OpenLayers.Class(OpenLayers.Format.GML, {
  
  /**
   * APIProperty: xlsns
   */
  xlsns: 'http://www.opengis.net/xls',
  
  initialize: function(options) {
    OpenLayers.Format.GML.prototype.initialize.apply(this, [options]);
    
    this.featureName = 'xls:ReverseGeocodedLocation';
    
    this.setNamespace('gml', 'http://www.opengis.net/gml');
  },
  
  read: function(data) {
    if(typeof data == "string") { 
      data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
    }
    
    var geocodedAddressNodes = this.getElementsByTagNameNS(data.documentElement,
      this.xlsns, 'ReverseGeocodedLocation');
    var geocodedAddresses = [];
    for (var i = 0; i < geocodedAddressNodes.length; i++) {
      var geocodedAddress = this.parseGeocodedAddress(geocodedAddressNodes[i]);
      if (geocodedAddress) {
        geocodedAddresses.push(geocodedAddress);
      }
    }                      
    return geocodedAddresses;
  },
  
  parseGeocodedAddress: function(node) {
    var geocodedAddress = {};
    
    var nodeList = this.getElementsByTagNameNS(node, this.namespaces['gml'], 'Point');
    if (nodeList.length > 0) {
      var parser = this.parseGeometry['point'];
      geocodedAddress.geometry = parser.apply(this, [nodeList[0]]);
    }
    
    var nodeList = this.getElementsByTagNameNS(node, this.xlsns, 'Address');
    if (nodeList.length > 0) {
      // street & building
      var children = this.getElementsByTagNameNS(nodeList[0], this.xlsns, 'StreetAddress');
      if (children.length > 0) {
        var childNode = children[0].firstChild;
        while (childNode) {
          if (childNode.nodeType == 1) {
            if (childNode.tagName == 'xls:Street') {
              geocodedAddress.street = this.getChildValue(childNode);
            }
            else if (childNode.tagName == 'xls:Building') {
              geocodedAddress.number = childNode.getAttribute('number');
              geocodedAddress.subdivision = childNode.getAttribute('subdivision');
            }
          }
          childNode = childNode.nextSibling;
        }
      }
      // postalCode
      var children = this.getElementsByTagNameNS(nodeList[0], this.xlsns, 'PostalCode');
      if (children.length > 0) {
        geocodedAddress.postalCode = this.getChildValue(children[0]);
      }
      // place(s)
      var children = this.getElementsByTagNameNS(nodeList[0], this.xlsns, 'Place');
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        var type = child.getAttribute('type');
        var name = type.substr(0, 1).toLowerCase() + type.substr(1);
        geocodedAddress[name] = this.getChildValue(child);
      }
    }
    
    return geocodedAddress;
  },
  
  CLASS_NAME: 'Geodan.Format.ReverseGeocodeResponse'
});
/* ======================================================================
    Geodan/Geocoder.js
   ====================================================================== */

/* 
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

Geodan.Geocoder = OpenLayers.Class(OpenLayers.Control, {

    autocomplete: {
      minLength: 3,
      delay: 500
    },

    url: 'http://' + location.host + '/geocoder/geocode?',

    tooltip: ' Zoek op postcode of adres...',

    extentMargin: 1000,

    pointMargin: 1000,

    minimumZoomScale: 5000,

    /**
     * Straat of postcode die laatst geselecteerd is uit lijst.
     */
    lastSelectGroup:  null,

    inputSize: 40,

    initialize: function(options) {
        OpenLayers.Control.prototype.initialize.apply(this, arguments)

        this.autoActivate = true;
        this.allowSelection = true;
    },
    
    draw: function(px) {
	
		if (this.div == null){
			this.div = OpenLayers.Control.prototype.draw.apply(this, arguments);
		}

        var form = document.createElement('form');
        form.setAttribute('method', 'GET');
        form.setAttribute('action', '#');
		form.setAttribute('class','geocoderform');
        form.setAttribute('onsubmit', "javascript:return false;");

        // add input to div
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        input.setAttribute('size', this.inputSize);
        input.setAttribute('title', this.tooltip);
        input.setAttribute('class', 'form-autocomplete');
        input.setAttribute('id', this.id + '-input');
        form.appendChild(input);

        // add form to div
        this.div.appendChild(form);

        //id="address" type="text" size="40" value=""
        return this.div;
    },

    activate: function() {

        // append autocomplete
        this.attachAutocomplete();

        // give input field focus
        //$('input', this.div).focus();
		$('input', this.div).val(this.tooltip);

        // prevent passthrough of mouse events
        ////OpenLayers.Event.observe(this.div, 'click', this.ignoreEvent);
        var context = {
            geocoder: this
        };
        OpenLayers.Event.observe(this.div, 'click',
            OpenLayers.Function.bindAsEventListener(this.onInputClick, context));
        //OpenLayers.Event.observe(this.div, 'dblclick', this.ignoreEvent);
        //OpenLayers.Event.observe(this.div, 'mousedown', this.ignoreEvent);
    },

    attachAutocomplete: function() {
        var self = this;
        // attach autocomplete event
        $('input', this.div).autocomplete(
		{
            minLength: this.autocomplete.minLength,
            delay: this.autocomplete.delay,
			appendTo: this.div,
            source: function(request, response) {
                try {
                    var url, ajax_data;

                    if (OpenLayers.ProxyHost == '') {
                        // no proxy needed
                        url = self.url;
                        ajax_data = self.params(request);
                    }
                    else {
                        // proxy needed
                        url = Geodan.Settings.proxyUrl;
                        ajax_data = {};
                        ajax_data['url'] = self.url
                            + (self.url.indexOf('?') < 0 ? '?' : '&')
                            + $.param(self.params(request))
                            ;
                    }
                    $('input', self.div).addClass('throbbing');
                    $.ajax({
                        url: url,
                        dataType: 'xml',
                        data: ajax_data,
                        success: function(data) {
                            return self.success.apply(self, [data, response, request]);
                        },
                        /*error: function(xmlHttpRequest, textStatus, errorThrown) {
                            console.log(OpenLayers.i18n('Geocoding failed: ${statusText} (${statusCode})', {
                                statusText: xmlHttpRequest.statusText,
                                statusCode: xmlHttpRequest.status
                            }));
                        },*/
                        complete: function(xmlHttpRequest, textStatus) {
                            $('input', self.div).removeClass('throbbing');
                        }
                    });
                } catch (e) {
					// do nothing?
                }
            },
			// setting the lastSelectGroup also on focus to be able to 'keep typing'
			focus: function(event, ui) {
			    if (ui.item && ui.item.address) {
					self.lastSelectGroup = ui.item.value;
				}
			},
            select: function(event, ui) {
                var extent, point, margin;

                if (ui.item) {
                    if (ui.item.address) {
						self.lastSelectGroup = ui.item.value;
                        if (ui.item.address.extent) {
                            margin = self.extentMargin;
                            extent = ui.item.address.extent;
                            // add margin
                            extent.left -= margin;
                            extent.bottom -= margin;
                            extent.top += margin;
                            extent.right += margin;
                            self.zoomToExtent(extent);
                        }
                        else if (ui.item.address.geometry) {
                            // point
                            margin = self.pointMargin;
                            point = ui.item.address.geometry;
                            extent = new OpenLayers.Bounds(point.x - margin
                                ,point.y - margin, point.x + margin, point.y + margin);
                            self.zoomToExtent(extent);
                        }
                    }
                    else {
                        //alert('TODO: zoom naar ' + ui.item.value);
                    }
					/*
					  // apply geocoder to ui.item.value
					  var geocoder = new Geodan.Geocoder({
						"method": 'GET',
						"url": self.geocoderUrl
					  });
					  var search = ui.item.value;
					  geocoder.geocode(search, OpenLayers.Function.bind(self.onFound, self));
					 */
                    //console && console.info("Selected: ", ui.item);
                }
                else {
                    //console && console.info("Nothing selected, input was " + this.value);
                }
            }
        });
    },

    params: function(request) {
        // mogelijke params: pc, address, town, muni (gemeente), number, prov
        var params = {
            country: 'Nederland'
        };
        // match postcode (1) of gemeente (3), straat (5)
        // match postcode (1) of straat () met huisnummer(s), gescheiden door spatie(s) en optionele komma

        var match = request.term.match(/(^[1-9][0-9]{1,3}[a-zA-Z]{0,2})|((^[^,]*)(,\s*(.*))?)/);
        //console && console.info('search match', match);
        if (match) {
            if (match[1]) {
				// postcode (vb: '3432ZJ' of '3432ZJ 45')
				// als de huidige zoekterm precies hetzelfde is als de laatste geselecteerd (of gefocuste)
                if (this.lastSelectGroup && request.term.toLowerCase().indexOf(this.lastSelectGroup.toLowerCase()) == 0) {
                    params.postalCode = this.lastSelectGroup;
                    var remains = request.term.substr(this.lastSelectGroup.length);
                    params.building = $.trim(remains) + '*';
                }
                else {
                    params.postalCode = match[1] + '*';
                }
                request.searchParameter = 'postalCode';
            }
            else {
                // straat
				// als de huidige zoekterm precies hetzelfde is als de laatste geselecteerd (of gefocuste)
                if (this.lastSelectGroup && request.term.toLowerCase().indexOf(this.lastSelectGroup.toLowerCase()) == 0) {
                    params.street = this.lastSelectGroup;
                    var remains = match[2].substr(this.lastSelectGroup.length);
					// we do not want to sent a ' ' to the server, so we trim the remains,
					// but IE does not have trim: that's why jquery.trim here:
                    params.building = $.trim(remains) + '*';
                }
                else {
					
                    params.street = '*' + match[3] + '*';
                    if (match[5]) {
                        params.building = match[5] + ' *';
                    }
                }
                request.searchParameter = 'street';
            }
            return params;
        }
    },

    zoomToExtent: function(extent) {
        var diff;
        var resolution = OpenLayers.Util.getResolutionFromScale(this.minimumZoomScale, 'm');
        var minSize = this.map.getSize();
        minSize.w *= resolution;
        minSize.h *= resolution;
        var newSize = extent.getSize();
        if (minSize.w > newSize.w) {
            // newSize left/right vergroten
            diff = minSize.w - newSize.w;
            extent.left -= diff/2;
            extent.right += diff/2;
        }
        if (minSize.h > newSize.h) {
            // newSize top/bottom vergroten
            diff = minSize.h - newSize.h;
            extent.bottom -= diff/2;
            extent.top += diff/2;
        }
        // todo; compare size with extent
        this.map.zoomToExtent(extent, true);
    },

    success: function(data, response, request) {
        // make array of addresses (street, number, postalCode, municipality, municipalitySubdivision, geometry, countrySubdivision)
        // o Dropdownlist straatnamen gezocht op substring; inzoomen naar
        //   gekozen straat
        // o Dropdownlist huisnummers binnen gekozen straat, ditmaal niet op
        //   substring; bij selectie inzoomen naar adres (instelbaar zoomniveau)
        var format = new Geodan.Format.GeocodeResponse();
        var addresses = format.read(data);
        var numAddresses = addresses.length;
        var that = this;
        response( $.map( addresses, function(item) {
            var result = {};
            if (item.postalCode && request.searchParameter !== 'street') {
                result.label = item.postalCode + ' (' + item.street + (item.number ? ' ' + item.number : '') + ')';
                // geen huisnummers in value
                result.value = item.postalCode;
                if (numAddresses == 1 && request.term.toLowerCase() === item.postalCode.toLowerCase()) {
                    that.lastSelectGroup = item.postalCode;
                }
            }
            else {
                result.label = item.street + (item.number ? ' ' + item.number + (item.subdivision ? item.subdivision : '') : '');
                result.value = result.label;
                if (numAddresses == 1 && request.term.toLowerCase() === item.street.toLowerCase()) {
                    that.lastSelectGroup = item.street;
                }
            }
            result.address = item;
            return result;
        }));
    },

    /**
     * Method: ignoreEvent
     *
     * Parameters:
     * evt - {Event}
     */
    ignoreEvent: function(evt) {
        //OpenLayers.Event.stop(evt, true);
    },

    onInputClick: function(evt) {
		if (this.geocoder.tooltip == $('input', this.geocoder.div).val() ){
			$('input', this.geocoder.div).val("");
		}
		$('input', this.geocoder.div).focus();
        //this.geocoder.ignoreEvent(evt);
    },

    CLASS_NAME: 'Geodan.Geocoder'
});
/* ======================================================================
    Geodan/ReverseGeocoder.js
   ====================================================================== */

/**
 * @requires Geodan/Format/ReverseGeocodeRequest.Format.js
 * @requires Geodan/Format/ReverseGeocodeResponse.Format.js
 */

/**
 * Class: Geodan.ReverseGeocoder
 * Request address for given coordinates.
 *
 * Inherits from:
 *  - <none>
 */
Geodan.ReverseGeocoder = OpenLayers.Class({
  /**
   * Note: reverseGeocodeUrl moet eindigen op ? of &.
   */
  url: 'http://geoserver.nl/geocoderrvs/NLaddressrvs.aspx?Request=revgeocode&',
  
  method: 'GET',
  
  initialize: function(options) {
    OpenLayers.Util.extend(this, options);
  },
  
  destroy: function() {
  },
  
  processAddresses: function(addresses) {
  },

  onFail: function(msg) {
    alert(msg);
  },
  
  /**
   *
   */
  reverseGeocode: function(point) {
    var host_match = this.url.match(/http:\/\/([^\/\:]*)(\:([0-9]{4}))?\//);
	// 1=hostname, 2=:port, 3=port
    var proxyIsNeeded = host_match.length >= 2 && host_match[1] != location.hostname;
    if (!proxyIsNeeded && host_match.length >= 3 && (host_match[3] ? host_match[3] : '') != location.port) {
      proxyIsNeeded = true;
    }
    var ajax_data = {};
    var ajax_url;
    var ajax_method = 'GET';
    if (this.method == 'POST') {
      ajax_method = 'POST';
      
      var format = new Geodan.Format.ReverseGeocodeRequest(null, point);
      if (proxyIsNeeded) {
        // proxy nodig
        ajax_url = OpenLayers.ProxyHost + escape(this.url);
      }
      else {
        ajax_url = this.url;
      }
      ajax_data = '<?xml version="1.0" encoding="UTF-8"?>' + format.write();
    }
    else {
      var data = { x: point.x, y: point.y };
      if (proxyIsNeeded) {
        // proxy nodig
        ajax_url = Geodan.Settings.proxyUrl; // todo: remove ?url=
        ajax_data.url = this.url + $.param(data);
      }
      else {
        // geen proxy nodig
        ajax_url = this.url;
        ajax_data = data;
      }
    }
    
    var options = {
      url: ajax_url,
      type: ajax_method,
      async: true,
      data: ajax_data,
      dataType: 'xml', // expected response type; should be XML, but seems to be JSON, so in Apache configuration mor.conf the response is forced to be XML, HansV, June 23, 2010
      timeout: 10000, // timeout in ms (10 sec)
      success: function(msg) {
        //alert('response = ' + msg);
        var response = new Geodan.Format.ReverseGeocodeResponse();
        addresses = response.read(msg);
        
        Geodan.ReverseGeocoder.prototype.processAddresses.apply(this, [addresses]);
        //alert('Debug-melding: Success [ReverseGeocoder.js]: ' + serialize(addresses));
      },
      error: function(xhr, textStatus, errorThrown) {
        // typically only one of textStatus or errorThrown 
        // will have info
        //this; // the options for this ajax request
        var msg;
        try {
          // try/catch omdat xhr.status niet gezet is na een timeout
          if (xhr.status != 200) {
            msg = 'Er is een fout opgetreden in [ReverseGeocoder.js]: ' + xhr.statusText + ' (' + xhr.status + ')';
          }
          else {
            msg = 'Er is een fout opgetreden in [ReverseGeocoder.js]: ' + xhr.responseText;
          }
        }
        catch (e) {
          msg = 'Er is een exceptie opgetreden in [ReverseGeocoder.js]: ' + textStatus;
        }
        finally {
          Geodan.ReverseGeocoder.prototype.onFail.apply(this, [msg]);
        }
      }
    };
    if (ajax_method == 'POST') {
      options.contentType = 'text/xml';
    }
    
    var addresses = null;
    var tmp = $.ajax(options);
    return addresses;
  },
  
  CLASS_NAME: "Geodan.ReverseGeocoder"
});
